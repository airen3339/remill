From 452f2aefe2f730c640bf7bfa74d9afaaa0718ac7 Mon Sep 17 00:00:00 2001
From: 2over12 <ian.smith@trailofbits.com>
Date: Fri, 5 May 2023 16:10:45 -0400
Subject: [PATCH] ia

---
 Ghidra/Processors/x86/data/languages/ia.sinc | 669 ++++++++++++++++---
 1 file changed, 576 insertions(+), 93 deletions(-)

diff --git a/Ghidra/Processors/x86/data/languages/ia.sinc b/Ghidra/Processors/x86/data/languages/ia.sinc
index 975b8d94a..eeecdc467 100644
--- a/Ghidra/Processors/x86/data/languages/ia.sinc
+++ b/Ghidra/Processors/x86/data/languages/ia.sinc
@@ -9,6 +9,13 @@
 @endif
 
 define endian=little;
+@ifdef IA64
+@define INST_NEXT_PTR "RIP"
+@else
+@define INST_NEXT_PTR "EIP"
+@endif
+define pcodeop claim_eq;
+
 
 define space ram type=ram_space size=$(SIZE) default;
 define space register type=register_space size=4;
@@ -576,6 +583,9 @@ define pcodeop vmxon;    # Enter VMX operation; opcode f3 0f C7 /6
 @define LONGMODE_OFF "opsize=opsize" # NOP
 @endif
 
+
+remill_insn_size: calculated_size is epsilon [calculated_size= inst_next-inst_start; ] { local insn_size_hinted:$(SIZE)=calculated_size; 
+ export insn_size_hinted; }
 @ifdef IA64
 Reg8:   reg8        is rexprefix=0 & reg8                               { export reg8; }
 Reg8:   reg8_x0     is rexprefix=1 & rexRprefix=0 & reg8_x0             { export reg8_x0; }
@@ -674,7 +684,12 @@ usimm8_64: val is imm8 & imm8_7=1 [ val = 0xffffffffffffff00 | imm8; ] { export
 #usimm16_32: val is imm16 & imm16_15=1 [ val = 0xffff0000 | imm16; ] { export *[const]:4 val; }
 
 # RIP/EIP relative address - NOTE: export of size 0 is intentional so it may be adjusted
-pcRelSimm32: addr	is simm32 [ addr=inst_next+simm32; ] { export addr; }
+pcRelSimm32: addr	is simm32  ; remill_insn_size [ addr=inst_next+simm32; ] { 
+remill_please_dont_use_this_temp_namea5:$(SIZE)=addr;
+claim_eq(remill_please_dont_use_this_temp_namea5, $(INST_NEXT_PTR)+simm32);
+ export addr;
+   }
+ 
 
 # 16-bit addressing modes   (the offset portion)
 addr16: [BX + SI]		is mod=0 & r_m=0 & BX & SI		{ local tmp=BX+SI; export tmp; }
@@ -753,8 +768,22 @@ addr64: [Base64 + Index64*ss + simm32_64] is mod=2 & r_m=4; Index64 & Base64 & s
 addr64: [Base64 + Index64*ss]			is mod=2 & r_m=4; Index64 & Base64 & ss; imm32=0   { local tmp=Base64+Index64*ss; export tmp; }
 @endif
 
-currentCS: CS is protectedMode=0 & CS { tmp:4 = (inst_next >> 4) & 0xf000; CS = tmp:2; export CS; }
-currentCS: CS is protectedMode=1 & CS { tmp:4 = (inst_next >> 16) & 0xffff; CS = tmp:2; export CS; }
+currentCS: CS is protectedMode=0 & CS  ; remill_insn_size  { 
+remill_please_dont_use_this_temp_name124:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name124, $(INST_NEXT_PTR));
+ tmp:4 = (inst_next >> 4) & 0xf000;
+ CS = tmp:2;
+ export CS;
+   }
+ 
+currentCS: CS is protectedMode=1 & CS  ; remill_insn_size  { 
+remill_please_dont_use_this_temp_name126:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name126, $(INST_NEXT_PTR));
+ tmp:4 = (inst_next >> 16) & 0xffff;
+ CS = tmp:2;
+ export CS;
+   }
+ 
  
 segWide: is segover=0		        { export 0:$(SIZE); }
 segWide: CS: is segover=1 & CS	{ export 0:$(SIZE); }
@@ -795,9 +824,24 @@ Mem: segWide^addr32 is $(LONGMODE_OFF) & addrsize=1 & segWide; addr32       		{
 @endif
 Mem: segWide^addr32 is $(LONGMODE_OFF) & addrsize=1 & segWide & highseg=1; addr32 	{ tmp:$(SIZE) = segWide + zext(addr32); export tmp; }
 
-rel8: reloc is simm8        [ reloc=inst_next+simm8; ] { export *[ram]:$(SIZE) reloc; }
-rel16: reloc is simm16      [ reloc=((inst_next >> 16) << 16) | ((inst_next + simm16) & 0xFFFF); ] { export *[ram]:$(SIZE) reloc; }
-rel32: reloc is simm32      [ reloc=inst_next+simm32; ] { export *[ram]:$(SIZE) reloc; }
+rel8: reloc is simm8         ; remill_insn_size [ reloc=inst_next+simm8; ] { 
+remill_please_dont_use_this_temp_name168:$(SIZE)=reloc;
+claim_eq(remill_please_dont_use_this_temp_name168, $(INST_NEXT_PTR)+simm8);
+ export *[ram]:$(SIZE) reloc;
+   }
+ 
+rel16: reloc is simm16       ; remill_insn_size [ reloc=((inst_next >> 16) << 16) | ((inst_next + simm16) & 0xFFFF); ] { 
+remill_please_dont_use_this_temp_name16b:$(SIZE)=reloc;
+claim_eq(remill_please_dont_use_this_temp_name16b, (($(INST_NEXT_PTR) >> 16) << 16) | (($(INST_NEXT_PTR) + simm16) & 0xFFFF));
+ export *[ram]:$(SIZE) reloc;
+   }
+ 
+rel32: reloc is simm32       ; remill_insn_size [ reloc=inst_next+simm32; ] { 
+remill_please_dont_use_this_temp_name16e:$(SIZE)=reloc;
+claim_eq(remill_please_dont_use_this_temp_name16e, $(INST_NEXT_PTR)+simm32);
+ export *[ram]:$(SIZE) reloc;
+   }
+ 
 
 
 m8:   "byte ptr" Mem   	is Mem      { export *:1 Mem; }
@@ -1054,30 +1098,99 @@ cc: "LE" is cond=14         { local tmp = ZF || (OF != SF); export tmp; }
 cc: "G" is cond=15          { local tmp = !ZF && (OF == SF); export tmp; }
 
 # repeat prefixes
-rep: ".REP" is ((repprefx=1 & repneprefx=0)|(repprefx=0 & repneprefx=1)) & addrsize=0  { if (CX==0) goto inst_next; CX=CX-1; }
-rep: ".REP" is ((repprefx=1 & repneprefx=0)|(repprefx=0 & repneprefx=1)) & addrsize=1  { if (ECX==0) goto inst_next; ECX=ECX-1; }
+rep: ".REP" is ((repprefx=1 & repneprefx=0)|(repprefx=0 & repneprefx=1)) & addrsize=0   ; remill_insn_size  { 
+remill_please_dont_use_this_temp_name2b5:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name2b5, $(INST_NEXT_PTR));
+ if (CX==0) goto inst_next;
+ CX=CX-1;
+   }
+ 
+rep: ".REP" is ((repprefx=1 & repneprefx=0)|(repprefx=0 & repneprefx=1)) & addrsize=1   ; remill_insn_size  { 
+remill_please_dont_use_this_temp_name2b7:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name2b7, $(INST_NEXT_PTR));
+ if (ECX==0) goto inst_next;
+ ECX=ECX-1;
+   }
+ 
 @ifdef IA64
-rep: ".REP" is ((repprefx=1 & repneprefx=0)|(repprefx=0 & repneprefx=1)) & addrsize=2  { if (RCX==0) goto inst_next; RCX=RCX-1; }
+rep: ".REP" is ((repprefx=1 & repneprefx=0)|(repprefx=0 & repneprefx=1)) & addrsize=2   ; remill_insn_size  { 
+remill_please_dont_use_this_temp_name2b9:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name2b9, $(INST_NEXT_PTR));
+ if (RCX==0) goto inst_next;
+ RCX=RCX-1;
+   }
+ 
 @endif
 rep:        is repprefx=0 & repneprefx=0			{ }
 
-reptail:	is ((repprefx=1 & repneprefx=0)|(repprefx=0 & repneprefx=1))			{ goto inst_start; }
+reptail:	is ((repprefx=1 & repneprefx=0)|(repprefx=0 & repneprefx=1))			 ; remill_insn_size  { 
+remill_please_dont_use_this_temp_name2be:$(SIZE)=inst_start;
+claim_eq(remill_please_dont_use_this_temp_name2be, ($(INST_NEXT_PTR)-remill_insn_size));
+ goto inst_start;
+   }
+ 
 reptail:	is repprefx=0 & repneprefx=0			{ }
 
-repe: ".REPE"   is repprefx=1 & repneprefx=0 & addrsize=0  { if (CX==0) goto inst_next; CX=CX-1; }
-repe: ".REPE"   is repprefx=1 & repneprefx=0 & addrsize=1  { if (ECX==0) goto inst_next; ECX=ECX-1; }
+repe: ".REPE"   is repprefx=1 & repneprefx=0 & addrsize=0   ; remill_insn_size  { 
+remill_please_dont_use_this_temp_name2c1:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name2c1, $(INST_NEXT_PTR));
+ if (CX==0) goto inst_next;
+ CX=CX-1;
+   }
+ 
+repe: ".REPE"   is repprefx=1 & repneprefx=0 & addrsize=1   ; remill_insn_size  { 
+remill_please_dont_use_this_temp_name2c3:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name2c3, $(INST_NEXT_PTR));
+ if (ECX==0) goto inst_next;
+ ECX=ECX-1;
+   }
+ 
 @ifdef IA64
-repe: ".REPE"   is repprefx=1 & repneprefx=0 & addrsize=2  { if (RCX==0) goto inst_next; RCX=RCX-1; }
+repe: ".REPE"   is repprefx=1 & repneprefx=0 & addrsize=2   ; remill_insn_size  { 
+remill_please_dont_use_this_temp_name2c5:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name2c5, $(INST_NEXT_PTR));
+ if (RCX==0) goto inst_next;
+ RCX=RCX-1;
+   }
+ 
 @endif
-repe: ".REPNE"  is repneprefx=1 & repprefx=0 & addrsize=0    { if (CX==0) goto inst_next; CX=CX-1; }
-repe: ".REPNE"  is repneprefx=1 & repprefx=0 & addrsize=1    { if (ECX==0) goto inst_next; ECX=ECX-1; }
+repe: ".REPNE"  is repneprefx=1 & repprefx=0 & addrsize=0     ; remill_insn_size  { 
+remill_please_dont_use_this_temp_name2c7:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name2c7, $(INST_NEXT_PTR));
+ if (CX==0) goto inst_next;
+ CX=CX-1;
+   }
+ 
+repe: ".REPNE"  is repneprefx=1 & repprefx=0 & addrsize=1     ; remill_insn_size  { 
+remill_please_dont_use_this_temp_name2c9:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name2c9, $(INST_NEXT_PTR));
+ if (ECX==0) goto inst_next;
+ ECX=ECX-1;
+   }
+ 
 @ifdef IA64
-repe: ".REPNE"  is repneprefx=1 & repprefx=0 & addrsize=2    { if (RCX==0) goto inst_next; RCX=RCX-1; }
+repe: ".REPNE"  is repneprefx=1 & repprefx=0 & addrsize=2     ; remill_insn_size  { 
+remill_please_dont_use_this_temp_name2cb:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name2cb, $(INST_NEXT_PTR));
+ if (RCX==0) goto inst_next;
+ RCX=RCX-1;
+   }
+ 
 @endif
 repe:           is repprefx=0 & repneprefx=0    { }
 
-repetail:   is repprefx=1 & repneprefx=0           { if (ZF) goto inst_start; }
-repetail:   is repneprefx=1 & repprefx=0           { if (!ZF) goto inst_start; }
+repetail:   is repprefx=1 & repneprefx=0            ; remill_insn_size  { 
+remill_please_dont_use_this_temp_name2d0:$(SIZE)=inst_start;
+claim_eq(remill_please_dont_use_this_temp_name2d0, ($(INST_NEXT_PTR)-remill_insn_size));
+ if (ZF) goto inst_start;
+   }
+ 
+repetail:   is repneprefx=1 & repprefx=0            ; remill_insn_size  { 
+remill_please_dont_use_this_temp_name2d2:$(SIZE)=inst_start;
+claim_eq(remill_please_dont_use_this_temp_name2d2, ($(INST_NEXT_PTR)-remill_insn_size));
+ if (!ZF) goto inst_start;
+   }
+ 
 repetail:   is repprefx=0 & repneprefx=0           { }
 
 # XACQUIRE/XRELEASE prefix
@@ -2089,65 +2202,289 @@ with : lockprefx=0 {
 :BTS Rmr64,imm8     is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xf; byte=0xba; mod=3 & Rmr64 & reg_opcode=5; imm8   { local bit=imm8&0x3f; local val=(Rmr64>>bit)&1; Rmr64=Rmr64 | (1<<bit); CF=(val!=0); }
 @endif
 
-:CALL rel16     is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & opsize=0 & byte=0xe8; rel16     { push22(&:2 inst_next); call rel16; }
-:CALL rel16     is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=0 & byte=0xe8; rel16     { push42(&:2 inst_next); call rel16; }
+:CALL rel16     is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & opsize=0 & byte=0xe8; rel16      ; remill_insn_size  { 
+remill_please_dont_use_this_temp_name39b:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name39b, $(INST_NEXT_PTR));
+ push22(&:2 inst_next);
+ call rel16;
+   }
+ 
+:CALL rel16     is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=0 & byte=0xe8; rel16      ; remill_insn_size  { 
+remill_please_dont_use_this_temp_name39d:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name39d, $(INST_NEXT_PTR));
+ push42(&:2 inst_next);
+ call rel16;
+   }
+ 
 @ifdef IA64
-:CALL rel16     is $(LONGMODE_ON) & vexMode=0 & (addrsize=1 | addrsize=2) & opsize=0 & byte=0xe8; rel16     { push88(&:8 inst_next); call rel16; }
+:CALL rel16     is $(LONGMODE_ON) & vexMode=0 & (addrsize=1 | addrsize=2) & opsize=0 & byte=0xe8; rel16      ; remill_insn_size  { 
+remill_please_dont_use_this_temp_name39f:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name39f, $(INST_NEXT_PTR));
+ push88(&:8 inst_next);
+ call rel16;
+   }
+ 
 @endif
 
 #  When is a Call a Jump, when it jumps right after.  Not always the case but...
-:CALL rel16     is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & opsize=0 & byte=0xe8; simm16=0 & rel16      { push22(&:2 inst_next); goto rel16; }
-:CALL rel16     is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=0 & byte=0xe8; simm16=0 & rel16      { push42(&:2 inst_next); goto rel16; }
+:CALL rel16     is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & opsize=0 & byte=0xe8; simm16=0 & rel16       ; remill_insn_size  { 
+remill_please_dont_use_this_temp_name3a1:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name3a1, $(INST_NEXT_PTR));
+ push22(&:2 inst_next);
+ goto rel16;
+   }
+ 
+:CALL rel16     is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=0 & byte=0xe8; simm16=0 & rel16       ; remill_insn_size  { 
+remill_please_dont_use_this_temp_name3a3:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name3a3, $(INST_NEXT_PTR));
+ push42(&:2 inst_next);
+ goto rel16;
+   }
+ 
 @ifdef IA64
-:CALL rel16     is $(LONGMODE_ON) & vexMode=0 & (addrsize=1 | addrsize=2) & opsize=0 & byte=0xe8; simm16=0 & rel16      { push88(&:8 inst_next); goto rel16; }
+:CALL rel16     is $(LONGMODE_ON) & vexMode=0 & (addrsize=1 | addrsize=2) & opsize=0 & byte=0xe8; simm16=0 & rel16       ; remill_insn_size  { 
+remill_please_dont_use_this_temp_name3a5:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name3a5, $(INST_NEXT_PTR));
+ push88(&:8 inst_next);
+ goto rel16;
+   }
+ 
 @endif
 
-:CALL rel32     is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & opsize=1 & byte=0xe8; rel32     { push24(&:4 inst_next); call rel32; }
-:CALL rel32     is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=1 & byte=0xe8; rel32     { push44(&:4 inst_next); call rel32; }
+:CALL rel32     is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & opsize=1 & byte=0xe8; rel32      ; remill_insn_size  { 
+remill_please_dont_use_this_temp_name3a7:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name3a7, $(INST_NEXT_PTR));
+ push24(&:4 inst_next);
+ call rel32;
+   }
+ 
+:CALL rel32     is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=1 & byte=0xe8; rel32      ; remill_insn_size  { 
+remill_please_dont_use_this_temp_name3a9:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name3a9, $(INST_NEXT_PTR));
+ push44(&:4 inst_next);
+ call rel32;
+   }
+ 
 @ifdef IA64
-:CALL rel32     is $(LONGMODE_ON) & vexMode=0 & addrsize=1 & opsize=1 & byte=0xe8; rel32     { push88(&:8 inst_next); call rel32; }
-:CALL rel32     is $(LONGMODE_ON) & vexMode=0 & addrsize=2 & (opsize=1 | opsize=2) & byte=0xe8; rel32     { push88(&:8 inst_next); call rel32; }
+:CALL rel32     is $(LONGMODE_ON) & vexMode=0 & addrsize=1 & opsize=1 & byte=0xe8; rel32      ; remill_insn_size  { 
+remill_please_dont_use_this_temp_name3ab:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name3ab, $(INST_NEXT_PTR));
+ push88(&:8 inst_next);
+ call rel32;
+   }
+ 
+:CALL rel32     is $(LONGMODE_ON) & vexMode=0 & addrsize=2 & (opsize=1 | opsize=2) & byte=0xe8; rel32      ; remill_insn_size  { 
+remill_please_dont_use_this_temp_name3ad:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name3ad, $(INST_NEXT_PTR));
+ push88(&:8 inst_next);
+ call rel32;
+   }
+ 
 @endif
 
 #  When is a call a Jump, when it jumps right after.  Not always the case but...
-:CALL rel32     is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & opsize=1 & byte=0xe8; simm32=0 & rel32      { push24(&:4 inst_next); goto rel32; }
-:CALL rel32     is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=1 & byte=0xe8; simm32=0 & rel32      { push44(&:4 inst_next); goto rel32; }
+:CALL rel32     is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & opsize=1 & byte=0xe8; simm32=0 & rel32       ; remill_insn_size  { 
+remill_please_dont_use_this_temp_name3af:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name3af, $(INST_NEXT_PTR));
+ push24(&:4 inst_next);
+ goto rel32;
+   }
+ 
+:CALL rel32     is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=1 & byte=0xe8; simm32=0 & rel32       ; remill_insn_size  { 
+remill_please_dont_use_this_temp_name3b1:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name3b1, $(INST_NEXT_PTR));
+ push44(&:4 inst_next);
+ goto rel32;
+   }
+ 
 @ifdef IA64
-:CALL rel32     is $(LONGMODE_ON) & vexMode=0 & addrsize=1 & opsize=1 & byte=0xe8; simm32=0 & rel32     { push88(&:8 inst_next); goto rel32; }
-:CALL rel32     is $(LONGMODE_ON) & vexMode=0 & addrsize=2 & (opsize=1 | opsize=2) & byte=0xe8; simm32=0 & rel32      { push88(&:8 inst_next); goto rel32; }
+:CALL rel32     is $(LONGMODE_ON) & vexMode=0 & addrsize=1 & opsize=1 & byte=0xe8; simm32=0 & rel32      ; remill_insn_size  { 
+remill_please_dont_use_this_temp_name3b3:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name3b3, $(INST_NEXT_PTR));
+ push88(&:8 inst_next);
+ goto rel32;
+   }
+ 
+:CALL rel32     is $(LONGMODE_ON) & vexMode=0 & addrsize=2 & (opsize=1 | opsize=2) & byte=0xe8; simm32=0 & rel32       ; remill_insn_size  { 
+remill_please_dont_use_this_temp_name3b5:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name3b5, $(INST_NEXT_PTR));
+ push88(&:8 inst_next);
+ goto rel32;
+   }
+ 
 @endif
 
-:CALL rm16	    is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & opsize=0 & byte=0xff & currentCS; rm16 & reg_opcode=2 ...	{ local dest:4 = segment(currentCS,rm16); push22(&:2 inst_next); call [dest]; }
-:CALL rm16      is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=0 & byte=0xff; rm16 & reg_opcode=2 ...   { local dest:2 = rm16; push42(&:2 inst_next); call [dest]; }
+:CALL rm16	    is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & opsize=0 & byte=0xff & currentCS; rm16 & reg_opcode=2 ...	 ; remill_insn_size  { 
+ local dest:4 = segment(currentCS,rm16);
+remill_please_dont_use_this_temp_name3b7:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name3b7, $(INST_NEXT_PTR));
+ push22(&:2 inst_next);
+ call [dest];
+   }
+ 
+:CALL rm16      is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=0 & byte=0xff; rm16 & reg_opcode=2 ...    ; remill_insn_size  { 
+ local dest:2 = rm16;
+remill_please_dont_use_this_temp_name3b9:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name3b9, $(INST_NEXT_PTR));
+ push42(&:2 inst_next);
+ call [dest];
+   }
+ 
 @ifdef IA64
-:CALL rm16      is $(LONGMODE_ON) & vexMode=0 & (addrsize=1 | addrsize=2) & opsize=0 & byte=0xff; rm16 & reg_opcode=2 ...   { local dest:8 = inst_next + zext(rm16); push88(&:8 inst_next); call [dest]; }
+:CALL rm16      is $(LONGMODE_ON) & vexMode=0 & (addrsize=1 | addrsize=2) & opsize=0 & byte=0xff; rm16 & reg_opcode=2 ...    ; remill_insn_size  { 
+remill_please_dont_use_this_temp_name3bb:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name3bb, $(INST_NEXT_PTR));
+ local dest:8 = inst_next + zext(rm16);
+claim_eq(remill_please_dont_use_this_temp_name3bb, $(INST_NEXT_PTR));
+ push88(&:8 inst_next);
+ call [dest];
+   }
+ 
 @endif
 
-:CALL rm32      is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & opsize=1 & byte=0xff; rm32 & reg_opcode=2 ...   { local dest:4 = rm32; push24(&:4 inst_next); call [dest]; }
-:CALL rm32      is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=1 & byte=0xff; rm32 & reg_opcode=2 ...   { local dest:4 = rm32; push44(&:4 inst_next); call [dest]; }
+:CALL rm32      is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & opsize=1 & byte=0xff; rm32 & reg_opcode=2 ...    ; remill_insn_size  { 
+ local dest:4 = rm32;
+remill_please_dont_use_this_temp_name3bd:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name3bd, $(INST_NEXT_PTR));
+ push24(&:4 inst_next);
+ call [dest];
+   }
+ 
+:CALL rm32      is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=1 & byte=0xff; rm32 & reg_opcode=2 ...    ; remill_insn_size  { 
+ local dest:4 = rm32;
+remill_please_dont_use_this_temp_name3bf:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name3bf, $(INST_NEXT_PTR));
+ push44(&:4 inst_next);
+ call [dest];
+   }
+ 
 @ifdef IA64
-:CALL rm64      is $(LONGMODE_ON) & vexMode=0 & (addrsize=1 | addrsize=2) & (opsize=1 | opsize=2) & byte=0xff; rm64 & reg_opcode=2 ...   { local dest:8 = rm64; push88(&:8 inst_next); call [dest]; }
+:CALL rm64      is $(LONGMODE_ON) & vexMode=0 & (addrsize=1 | addrsize=2) & (opsize=1 | opsize=2) & byte=0xff; rm64 & reg_opcode=2 ...    ; remill_insn_size  { 
+ local dest:8 = rm64;
+remill_please_dont_use_this_temp_name3c1:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name3c1, $(INST_NEXT_PTR));
+ push88(&:8 inst_next);
+ call [dest];
+   }
+ 
 @endif
 
 # direct far calls generate an opcode undefined exception in x86-64
-:CALLF ptr1616      is vexMode=0 & addrsize=0 & opsize=0 & byte=0x9a; ptr1616           { push22(CS); build ptr1616; push22(&:2 inst_next); call ptr1616; }
-:CALLF ptr1616      is vexMode=0 & addrsize=1 & opsize=0 & byte=0x9a; ptr1616           { push42(CS); build ptr1616; push42(&:2 inst_next); call ptr1616; }
-:CALLF ptr1632      is vexMode=0 & addrsize=0 & opsize=1 & byte=0x9a; ptr1632           { push22(CS); build ptr1632; push24(&:4 inst_next); call ptr1632; }
-:CALLF ptr1632      is vexMode=0 & addrsize=1 & opsize=1 & byte=0x9a; ptr1632           { push42(CS); build ptr1632; push44(&:4 inst_next); call ptr1632; }
-:CALLF addr16       is vexMode=0 & addrsize=0 & opsize=0 & byte=0xff; addr16 & reg_opcode=3 ... { local ptr:$(SIZE) = segment(DS,addr16); local addrptr:$(SIZE) = segment(*:2 (ptr+2),*:2 ptr);
-                                                                                                  push22(CS); push22(&:2 inst_next); call [addrptr]; }
-:CALLF addr32       is vexMode=0 & addrsize=1 & opsize=0 & byte=0xff; addr32 & reg_opcode=3 ... { local dest:4 = addr32; push42(CS); push42(&:2 inst_next); call [dest]; }
+:CALLF ptr1616      is vexMode=0 & addrsize=0 & opsize=0 & byte=0x9a; ptr1616            ; remill_insn_size  { 
+ push22(CS);
+ build ptr1616;
+remill_please_dont_use_this_temp_name3c3:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name3c3, $(INST_NEXT_PTR));
+ push22(&:2 inst_next);
+ call ptr1616;
+   }
+ 
+:CALLF ptr1616      is vexMode=0 & addrsize=1 & opsize=0 & byte=0x9a; ptr1616            ; remill_insn_size  { 
+ push42(CS);
+ build ptr1616;
+remill_please_dont_use_this_temp_name3c5:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name3c5, $(INST_NEXT_PTR));
+ push42(&:2 inst_next);
+ call ptr1616;
+   }
+ 
+:CALLF ptr1632      is vexMode=0 & addrsize=0 & opsize=1 & byte=0x9a; ptr1632            ; remill_insn_size  { 
+ push22(CS);
+ build ptr1632;
+remill_please_dont_use_this_temp_name3c7:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name3c7, $(INST_NEXT_PTR));
+ push24(&:4 inst_next);
+ call ptr1632;
+   }
+ 
+:CALLF ptr1632      is vexMode=0 & addrsize=1 & opsize=1 & byte=0x9a; ptr1632            ; remill_insn_size  { 
+ push42(CS);
+ build ptr1632;
+remill_please_dont_use_this_temp_name3c9:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name3c9, $(INST_NEXT_PTR));
+ push44(&:4 inst_next);
+ call ptr1632;
+   }
+ 
+:CALLF addr16       is vexMode=0 & addrsize=0 & opsize=0 & byte=0xff; addr16 & reg_opcode=3 ...  ; remill_insn_size  { 
+ local ptr:$(SIZE) = segment(DS,addr16);
+ local addrptr:$(SIZE) = segment(*:2 (ptr+2),*:2 ptr);
+
+                                                                                                  push22(CS);
+remill_please_dont_use_this_temp_name3cb:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name3cb, $(INST_NEXT_PTR));
+ push22(&:2 inst_next);
+ call [addrptr];
+   }
+ 
+:CALLF addr32       is vexMode=0 & addrsize=1 & opsize=0 & byte=0xff; addr32 & reg_opcode=3 ...  ; remill_insn_size  { 
+ local dest:4 = addr32;
+ push42(CS);
+remill_please_dont_use_this_temp_name3cd:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name3cd, $(INST_NEXT_PTR));
+ push42(&:2 inst_next);
+ call [dest];
+   }
+ 
 @ifdef IA64
-:CALLF addr64       is $(LONGMODE_ON) & vexMode=0 & addrsize=2 & opsize=0 & byte=0xff; addr64 & reg_opcode=3 ... { local dest:8 = addr64; push82(CS); push82(&:2 inst_next); call [dest]; }
+:CALLF addr64       is $(LONGMODE_ON) & vexMode=0 & addrsize=2 & opsize=0 & byte=0xff; addr64 & reg_opcode=3 ...  ; remill_insn_size  { 
+ local dest:8 = addr64;
+ push82(CS);
+remill_please_dont_use_this_temp_name3cf:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name3cf, $(INST_NEXT_PTR));
+ push82(&:2 inst_next);
+ call [dest];
+   }
+ 
 @endif
 
 
-:CALLF addr16       is vexMode=0 & addrsize=0 & opsize=1 & byte=0xff; addr16 & reg_opcode=3 ... { local dest:2 = addr16; push22(CS); push24(&:4 inst_next); call [dest]; }
-:CALLF addr32       is vexMode=0 & addrsize=1 & opsize=1 & byte=0xff; addr32 & reg_opcode=3 ... { local dest:4 = addr32; push42(CS); push44(&:4 inst_next); call [dest]; }
+:CALLF addr16       is vexMode=0 & addrsize=0 & opsize=1 & byte=0xff; addr16 & reg_opcode=3 ...  ; remill_insn_size  { 
+ local dest:2 = addr16;
+ push22(CS);
+remill_please_dont_use_this_temp_name3d1:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name3d1, $(INST_NEXT_PTR));
+ push24(&:4 inst_next);
+ call [dest];
+   }
+ 
+:CALLF addr32       is vexMode=0 & addrsize=1 & opsize=1 & byte=0xff; addr32 & reg_opcode=3 ...  ; remill_insn_size  { 
+ local dest:4 = addr32;
+ push42(CS);
+remill_please_dont_use_this_temp_name3d3:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name3d3, $(INST_NEXT_PTR));
+ push44(&:4 inst_next);
+ call [dest];
+   }
+ 
 @ifdef IA64
-:CALLF addr32       is $(LONGMODE_ON) &vexMode=0 & addrsize=1 & opsize=2 & byte=0xff; addr32 & reg_opcode=3 ... { local dest:4 = addr32; push82(CS); push88(&:8 inst_next); call [dest]; }
-:CALLF addr64       is $(LONGMODE_ON) &vexMode=0 & addrsize=2 & opsize=1 & byte=0xff; addr64 & reg_opcode=3 ... { local dest:8 = addr64; push82(CS); push84(&:4 inst_next); call [dest]; }
-:CALLF addr64       is $(LONGMODE_ON) &vexMode=0 & addrsize=2 & opsize=2 & byte=0xff; addr64 & reg_opcode=3 ... { local dest:8 = addr64; push82(CS); push88(&:8 inst_next); call [dest]; }
+:CALLF addr32       is $(LONGMODE_ON) &vexMode=0 & addrsize=1 & opsize=2 & byte=0xff; addr32 & reg_opcode=3 ...  ; remill_insn_size  { 
+ local dest:4 = addr32;
+ push82(CS);
+remill_please_dont_use_this_temp_name3d5:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name3d5, $(INST_NEXT_PTR));
+ push88(&:8 inst_next);
+ call [dest];
+   }
+ 
+:CALLF addr64       is $(LONGMODE_ON) &vexMode=0 & addrsize=2 & opsize=1 & byte=0xff; addr64 & reg_opcode=3 ...  ; remill_insn_size  { 
+ local dest:8 = addr64;
+ push82(CS);
+remill_please_dont_use_this_temp_name3d7:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name3d7, $(INST_NEXT_PTR));
+ push84(&:4 inst_next);
+ call [dest];
+   }
+ 
+:CALLF addr64       is $(LONGMODE_ON) &vexMode=0 & addrsize=2 & opsize=2 & byte=0xff; addr64 & reg_opcode=3 ...  ; remill_insn_size  { 
+ local dest:8 = addr64;
+ push82(CS);
+remill_please_dont_use_this_temp_name3d9:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name3d9, $(INST_NEXT_PTR));
+ push88(&:8 inst_next);
+ call [dest];
+   }
+ 
 @endif
 
 :CBW            is vexMode=0 & opsize=0 & byte=0x98                 { AX = sext(AL); }
@@ -2190,10 +2527,29 @@ define pcodeop clzero;
 
 :CMC			is vexMode=0 & byte=0xf5						{ CF = CF==0; }
 
-:CMOV^cc Reg16,rm16 is vexMode=0 & opsize=0 & byte=0xf; row=4 & cc; rm16 & Reg16 ...    { if (!cc) goto inst_next; Reg16 = rm16; }
-:CMOV^cc Reg32,rm32 is vexMode=0 & opsize=1 & byte=0xf; row=4 & cc; rm32 & Reg32 ... & check_Reg32_dest ...   { build check_Reg32_dest; if (!cc) goto inst_next; Reg32 = rm32;}
+:CMOV^cc Reg16,rm16 is vexMode=0 & opsize=0 & byte=0xf; row=4 & cc; rm16 & Reg16 ...     ; remill_insn_size  { 
+remill_please_dont_use_this_temp_name3fb:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name3fb, $(INST_NEXT_PTR));
+ if (!cc) goto inst_next;
+ Reg16 = rm16;
+   }
+ 
+:CMOV^cc Reg32,rm32 is vexMode=0 & opsize=1 & byte=0xf; row=4 & cc; rm32 & Reg32 ... & check_Reg32_dest ...    ; remill_insn_size  { 
+ build check_Reg32_dest;
+remill_please_dont_use_this_temp_name3fd:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name3fd, $(INST_NEXT_PTR));
+ if (!cc) goto inst_next;
+ Reg32 = rm32;
+  }
+ 
 @ifdef IA64
-:CMOV^cc Reg64,rm64 is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xf; row=4 & cc; rm64 & Reg64 ...    { if (!cc) goto inst_next; Reg64 = rm64; }
+:CMOV^cc Reg64,rm64 is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xf; row=4 & cc; rm64 & Reg64 ...     ; remill_insn_size  { 
+remill_please_dont_use_this_temp_name3ff:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name3ff, $(INST_NEXT_PTR));
+ if (!cc) goto inst_next;
+ Reg64 = rm64;
+   }
+ 
 @endif
 
 :CMP AL,imm8        is vexMode=0 & byte=0x3c; AL & imm8                                 { subflags(   AL,imm8 ); local tmp =    AL -   imm8; resultflags(tmp); }
@@ -2242,22 +2598,34 @@ define pcodeop clzero;
                                           local diff = Rmr16^Reg16; Rmr16 = Rmr16 ^ (zext(ZF) * diff);
                                           diff = AX ^ Rmr16; AX = AX ^ (zext(ZF==0) * diff); }
 :CMPXCHG Rmr32,Reg32    is vexMode=0 & opsize=1 & byte=0xf; byte=0xb1; mod=3 & Rmr32 & Reg32 & check_EAX_dest & check_Rmr32_dest
-{
+ ; remill_insn_size  { 
 	#this instruction writes to either EAX or Rmr32
 	#in 64-bit mode, a 32-bit register that is written to 
 	#(and only the register that is written to) 
 	#must be zero-extended to 64 bits
 	subflags(EAX,Rmr32);
+
 	local tmp=EAX-Rmr32;
-	resultflags(tmp);  
+
+	resultflags(tmp);
+  
     if (ZF==1) goto <equal>;
+
     EAX = Rmr32;
+
     build check_EAX_dest;
+remill_please_dont_use_this_temp_name42f:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name42f, $(INST_NEXT_PTR));
+
     goto inst_next;
+
 <equal>
     Rmr32 = Reg32;
+
     build check_Rmr32_dest;
-}
+
+  }
+ 
 @ifdef IA64
 :CMPXCHG Rmr64,Reg64    is $(LONGMODE_ON) & vexMode=0 & opsize=2 & byte=0xf; byte=0xb1; mod=3 & Rmr64 & Reg64  { subflags(RAX,Rmr64); local tmp=RAX-Rmr64; resultflags(tmp);
                                           local diff = Rmr64^Reg64; Rmr64 = Rmr64 ^ (zext(ZF) * diff);
@@ -2664,7 +3032,12 @@ enterFrames: low5 is low5 { tmp:1 = low5; export tmp; }
 # as a NOP.  We treat it as a NOP as well.
 :FSETPM 	is vexMode=0 & byte=0xdb; byte=0xe4	{ } # 80287 set protected mode
 
-:HLT            is vexMode=0 & byte=0xf4                        { goto inst_start; }
+:HLT            is vexMode=0 & byte=0xf4                         ; remill_insn_size  { 
+remill_please_dont_use_this_temp_name45e:$(SIZE)=inst_start;
+claim_eq(remill_please_dont_use_this_temp_name45e, ($(INST_NEXT_PTR)-remill_insn_size));
+ goto inst_start;
+   }
+ 
 
 :IDIV rm8       is vexMode=0 & byte=0xf6;  rm8 & reg_opcode=7 ...           { rm8ext:2 = sext(rm8);
                                                   local quotient = AX s/ rm8ext;  # DE exception if quotient doesn't fit in AL
@@ -3886,9 +4259,27 @@ define pcodeop skinit;
 @endif
 
 define pcodeop invalidInstructionException;
-:UD0  Reg32, rm32 is vexMode=0 & byte=0x0f; byte=0xff; rm32 & Reg32 ...           { invalidInstructionException(); goto inst_start; }
-:UD1  Reg32, rm32 is vexMode=0 & byte=0x0f; byte=0xb9; rm32 & Reg32 ...           { invalidInstructionException(); goto inst_start; }
-:UD2              is vexMode=0 & byte=0xf; byte=0xb                               { invalidInstructionException(); goto inst_start; }
+:UD0  Reg32, rm32 is vexMode=0 & byte=0x0f; byte=0xff; rm32 & Reg32 ...            ; remill_insn_size  { 
+ invalidInstructionException();
+remill_please_dont_use_this_temp_name878:$(SIZE)=inst_start;
+claim_eq(remill_please_dont_use_this_temp_name878, ($(INST_NEXT_PTR)-remill_insn_size));
+ goto inst_start;
+   }
+ 
+:UD1  Reg32, rm32 is vexMode=0 & byte=0x0f; byte=0xb9; rm32 & Reg32 ...            ; remill_insn_size  { 
+ invalidInstructionException();
+remill_please_dont_use_this_temp_name87a:$(SIZE)=inst_start;
+claim_eq(remill_please_dont_use_this_temp_name87a, ($(INST_NEXT_PTR)-remill_insn_size));
+ goto inst_start;
+   }
+ 
+:UD2              is vexMode=0 & byte=0xf; byte=0xb                                ; remill_insn_size  { 
+ invalidInstructionException();
+remill_please_dont_use_this_temp_name87c:$(SIZE)=inst_start;
+claim_eq(remill_please_dont_use_this_temp_name87c, ($(INST_NEXT_PTR)-remill_insn_size));
+ goto inst_start;
+   }
+ 
 
 define pcodeop verr;
 define pcodeop verw;
@@ -4127,14 +4518,62 @@ define pcodeop convert_bcd;
 :FCLEX          is vexMode=0 & byte=0x9B; byte=0xDB; byte=0xE2      { FPUStatusWord[0,8] = 0; FPUStatusWord[15,1] = 0; }
 :FNCLEX         is vexMode=0 & byte=0xDB; byte=0xE2                 { FPUStatusWord[0,8] = 0; FPUStatusWord[15,1] = 0; } 
 
-:FCMOVB ST0, freg   is vexMode=0 & byte=0xDA; frow=12 & fpage=0 & freg & ST0        { if ( !CF ) goto inst_next; ST0 = freg; }   
-:FCMOVE ST0, freg   is vexMode=0 & byte=0xDA; frow=12 & fpage=1 & freg & ST0        { if ( !ZF ) goto inst_next; ST0 = freg; }   
-:FCMOVBE ST0, freg  is vexMode=0 & byte=0xDA; frow=13 & fpage=0 & freg & ST0        { if ( !CF & !ZF ) goto inst_next; ST0 = freg; } 
-:FCMOVU  ST0, freg  is vexMode=0 & byte=0xDA; frow=13 & fpage=1 & freg & ST0        { if ( !PF ) goto inst_next; ST0 = freg; }   
-:FCMOVNB ST0, freg  is vexMode=0 & byte=0xDB; frow=12 & fpage=0 & freg & ST0        { if ( CF ) goto inst_next; ST0 = freg; }    
-:FCMOVNE ST0, freg  is vexMode=0 & byte=0xDB; frow=12 & fpage=1 & freg & ST0        { if ( ZF ) goto inst_next; ST0 = freg; }    
-:FCMOVNBE ST0, freg is vexMode=0 & byte=0xDB; frow=13 & fpage=0 & freg & ST0        { if ( CF & ZF ) goto inst_next; ST0 = freg; }   
-:FCMOVNU  ST0, freg is vexMode=0 & byte=0xDB; frow=13 & fpage=1 & freg & ST0        { if ( PF ) goto inst_next; ST0 = freg; }    
+:FCMOVB ST0, freg   is vexMode=0 & byte=0xDA; frow=12 & fpage=0 & freg & ST0         ; remill_insn_size  { 
+remill_please_dont_use_this_temp_name927:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name927, $(INST_NEXT_PTR));
+ if ( !CF ) goto inst_next;
+ ST0 = freg;
+   }
+    
+:FCMOVE ST0, freg   is vexMode=0 & byte=0xDA; frow=12 & fpage=1 & freg & ST0         ; remill_insn_size  { 
+remill_please_dont_use_this_temp_name929:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name929, $(INST_NEXT_PTR));
+ if ( !ZF ) goto inst_next;
+ ST0 = freg;
+   }
+    
+:FCMOVBE ST0, freg  is vexMode=0 & byte=0xDA; frow=13 & fpage=0 & freg & ST0         ; remill_insn_size  { 
+remill_please_dont_use_this_temp_name92b:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name92b, $(INST_NEXT_PTR));
+ if ( !CF & !ZF ) goto inst_next;
+ ST0 = freg;
+   }
+  
+:FCMOVU  ST0, freg  is vexMode=0 & byte=0xDA; frow=13 & fpage=1 & freg & ST0         ; remill_insn_size  { 
+remill_please_dont_use_this_temp_name92d:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name92d, $(INST_NEXT_PTR));
+ if ( !PF ) goto inst_next;
+ ST0 = freg;
+   }
+    
+:FCMOVNB ST0, freg  is vexMode=0 & byte=0xDB; frow=12 & fpage=0 & freg & ST0         ; remill_insn_size  { 
+remill_please_dont_use_this_temp_name92f:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name92f, $(INST_NEXT_PTR));
+ if ( CF ) goto inst_next;
+ ST0 = freg;
+   }
+     
+:FCMOVNE ST0, freg  is vexMode=0 & byte=0xDB; frow=12 & fpage=1 & freg & ST0         ; remill_insn_size  { 
+remill_please_dont_use_this_temp_name931:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name931, $(INST_NEXT_PTR));
+ if ( ZF ) goto inst_next;
+ ST0 = freg;
+   }
+     
+:FCMOVNBE ST0, freg is vexMode=0 & byte=0xDB; frow=13 & fpage=0 & freg & ST0         ; remill_insn_size  { 
+remill_please_dont_use_this_temp_name933:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name933, $(INST_NEXT_PTR));
+ if ( CF & ZF ) goto inst_next;
+ ST0 = freg;
+   }
+    
+:FCMOVNU  ST0, freg is vexMode=0 & byte=0xDB; frow=13 & fpage=1 & freg & ST0         ; remill_insn_size  { 
+remill_please_dont_use_this_temp_name935:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_name935, $(INST_NEXT_PTR));
+ if ( PF ) goto inst_next;
+ ST0 = freg;
+   }
+     
                                                                  
 :FCOM spec_m32       is vexMode=0 & byte=0xD8; reg_opcode=2 ... & spec_m32            { local tmp=float2float(spec_m32); fcom(tmp); }         
 :FCOM spec_m64       is vexMode=0 & byte=0xDC; reg_opcode=2 ... & spec_m64            { local tmp=float2float(spec_m64); fcom(tmp); }         
@@ -5628,30 +6067,52 @@ define pcodeop maxps;
 :MAXPS        XmmReg1, XmmReg2    is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x5F; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = maxps(XmmReg1, XmmReg2); }
 
 :MAXSD        XmmReg, m64         is vexMode=0 &  $(PRE_F2) & byte=0x0F; byte=0x5F; XmmReg ... & m64
-{
-    local tmp:8 = m64;
+ ; remill_insn_size  { 
+ local tmp:8 = m64;
+remill_please_dont_use_this_temp_nameb31:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_nameb31, $(INST_NEXT_PTR));
+
     if (tmp f< XmmReg[0,64]) goto inst_next;
+
     XmmReg[0,64] = tmp;
-}
+
+  }
+ 
 
 :MAXSD        XmmReg1, XmmReg2    is vexMode=0 &  $(PRE_F2) & byte=0x0F; byte=0x5F; xmmmod=3 & XmmReg1 & XmmReg2
-{
-    if (XmmReg2[0,64] f< XmmReg1[0,64]) goto inst_next;
+ ; remill_insn_size  { 
+remill_please_dont_use_this_temp_nameb33:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_nameb33, $(INST_NEXT_PTR));
+ if (XmmReg2[0,64] f< XmmReg1[0,64]) goto inst_next;
+
     XmmReg1[0,64] = XmmReg2[0,64];
-}
+
+  }
+ 
 
 :MAXSS        XmmReg, m32         is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x5F; XmmReg ... & m32
-{
-    local tmp:4 = m32;
+ ; remill_insn_size  { 
+ local tmp:4 = m32;
+remill_please_dont_use_this_temp_nameb35:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_nameb35, $(INST_NEXT_PTR));
+
     if (tmp f< XmmReg[0,32]) goto inst_next;
+
     XmmReg[0,32] = tmp;
-}
+
+  }
+ 
 
 :MAXSS        XmmReg1, XmmReg2    is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x5F; xmmmod=3 & XmmReg1 & XmmReg2
-{
-    if (XmmReg2[0,32] f< XmmReg1[0,32]) goto inst_next;
+ ; remill_insn_size  { 
+remill_please_dont_use_this_temp_nameb37:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_nameb37, $(INST_NEXT_PTR));
+ if (XmmReg2[0,32] f< XmmReg1[0,32]) goto inst_next;
+
     XmmReg1[0,32] = XmmReg2[0,32];
-}
+
+  }
+ 
 
 define pcodeop minpd;
 :MINPD        XmmReg, m128        is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x5D; XmmReg ... & m128 { XmmReg = minpd(XmmReg, m128); }
@@ -5662,30 +6123,52 @@ define pcodeop minps;
 :MINPS        XmmReg1, XmmReg2    is vexMode=0 &  mandover=0 & byte=0x0F; byte=0x5D; xmmmod=3 & XmmReg1 & XmmReg2 { XmmReg1 = minps(XmmReg1, XmmReg2); }
 
 :MINSD        XmmReg, m64         is vexMode=0 &  $(PRE_F2) & byte=0x0F; byte=0x5D; XmmReg ... & m64
-{
-    local tmp:8 = m64;
+ ; remill_insn_size  { 
+ local tmp:8 = m64;
+remill_please_dont_use_this_temp_nameb41:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_nameb41, $(INST_NEXT_PTR));
+
     if (XmmReg[0,64] f< tmp) goto inst_next;
+
     XmmReg[0,64] = tmp;
-}
+
+  }
+ 
 
 :MINSD        XmmReg1, XmmReg2    is vexMode=0 &  $(PRE_F2) & byte=0x0F; byte=0x5D; xmmmod=3 & XmmReg1 & XmmReg2
-{
-    if (XmmReg1[0,64] f< XmmReg2[0,64]) goto inst_next;
+ ; remill_insn_size  { 
+remill_please_dont_use_this_temp_nameb43:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_nameb43, $(INST_NEXT_PTR));
+ if (XmmReg1[0,64] f< XmmReg2[0,64]) goto inst_next;
+
     XmmReg1[0,64] = XmmReg2[0,64];
-}
+
+  }
+ 
 
 :MINSS        XmmReg, m32         is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x5D; XmmReg ... & m32
-{
-    local tmp:4 = m32;
+ ; remill_insn_size  { 
+ local tmp:4 = m32;
+remill_please_dont_use_this_temp_nameb45:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_nameb45, $(INST_NEXT_PTR));
+
     if (XmmReg[0,32] f< tmp) goto inst_next;
+
     XmmReg[0,32] = tmp;
-}
+
+  }
+ 
 
 :MINSS        XmmReg1, XmmReg2    is vexMode=0 &  $(PRE_F3) & byte=0x0F; byte=0x5D; xmmmod=3 & XmmReg1 & XmmReg2
-{
-    if (XmmReg1[0,32] f< XmmReg2[0,32]) goto inst_next;
+ ; remill_insn_size  { 
+remill_please_dont_use_this_temp_nameb47:$(SIZE)=inst_next;
+claim_eq(remill_please_dont_use_this_temp_nameb47, $(INST_NEXT_PTR));
+ if (XmmReg1[0,32] f< XmmReg2[0,32]) goto inst_next;
+
     XmmReg1[0,32] = XmmReg2[0,32];
-}
+
+  }
+ 
 
 :MOVAPD       XmmReg, m128        is vexMode=0 &  $(PRE_66) & byte=0x0F; byte=0x28; m128 & XmmReg ...
 {
-- 
2.39.2 (Apple Git-143)

